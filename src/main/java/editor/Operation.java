package editor;


import java.io.Serializable;
import java.util.Spliterator;

/**
 * An object to encapsulate information about modifications being made to a text
 * file. Implements Serializable to allow sending through netty Channel.
 */
public class Operation implements Serializable {

    private static final long serialVersionUID = 1L;

    public static final int PRINT = -1; // Mostly for debugging

    public static final int REPLACE = 3; // Replace the region with content
    public static final int INSERT = 2; // Adding text to the file
    public static final int DELETE = 1; // Removing text from the file
    public static final int NO_OP = 0; // No operation, do nothing
    public static final int ACK = 10; // Acknowledge op was applied
    public static final int CONNECT = 20;

    public int opsGenerated; // Number of ops generated by the op creator
    public int opsReceived; // Number of ops received by the op creator
    public int type; // "how" to execute this operation
    public int leftIdx; // Left index or insertion point
    public int rightIdx; // Right index, mainly for deletions
    public String content; // Applies only to INSERT ops
    public int clientId; // id of client that sent operation

    public Operation(int type) {
        this(type, "");
    }

    public Operation(int type, String content) {
        this.type = type;
        this.content = content;
    }

    public Operation(int opsGenerated, int opsReceived, int type, int leftIdx,
                     int rightIdx, int clientId) {
        this.opsGenerated = opsGenerated;
        this.opsReceived = opsReceived;
        this.type = type;
        this.leftIdx = leftIdx;
        this.rightIdx = rightIdx;
        this.clientId = clientId;
    }

    /**
     * Copy constructor
     */
    public Operation(Operation copy) {
        this.opsGenerated = copy.opsGenerated;
        this.opsReceived = copy.opsReceived;
        this.type = copy.type;
        this.leftIdx = copy.leftIdx;
        this.rightIdx = copy.rightIdx;
        this.content = copy.content;
        this.clientId = copy.clientId;
    }

    /**
     * Returns an insert operation; intended to be used for testing.
     */
    public static Operation insertOperation(int startPos, String content) {
        Operation op = new Operation(INSERT);
        op.leftIdx = startPos;
        op.content = content;
        return op;
    }

    /**
     * Returns a delete operation; intended to be used for testing.
     */
    public static Operation deleteOperation(int startPos, int finalPos) {
        Operation op = new Operation(DELETE);
        op.leftIdx = startPos;
        op.rightIdx = finalPos;
        return op;
    }

    public static Operation deleteOperation(int startPos) {
        return deleteOperation(startPos, startPos-1);
    }

    public static Operation[] transform(Operation A, Operation B) {
        Operation[] ops = new Operation[2];
        if (A.type == INSERT && B.type == INSERT) {
            return transformInsert(A, B);
        }
        if (A.type == DELETE && B.type == DELETE) {
            return transformDelete(A, B);
        }
        if (A.type == INSERT && B.type == DELETE) {
            return transformInsertDelete(A, B);
        }
        if (A.type == DELETE && B.type == INSERT) {
            return transformDeleteInsert(A, B);
        }
        return ops;
    }

    /**
     * Transforms two insert operations against each other
     * @param C is the client's operation
     * @param S is the server's operation
     */
    public static Operation[] transformInsert(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        int idxC = C.leftIdx;
        int idxS = S.leftIdx;
        Operation cPrime = new Operation(C); // to be executed by S
        Operation sPrime = new Operation(S); // to be executed by C

        // S inserts at a position after C's insert
        if (idxS > idxC) {
            // C must insert S's operation at a later position
            sPrime.leftIdx += C.content.length();
        }
        // S inserts at a position before C's insert
        if (idxS < idxC) {
            // S must insert C's operation at a later position
            cPrime.leftIdx += S.content.length();
        }
        // C inserts at the same position as S's insert
        if (idxC == idxS) {
            // Let S win, S must insert C's operation at a later position
            cPrime.leftIdx += S.content.length();
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    /**
     * Transforms two deletions against each other.
     * @param C is the client's operation.
     * @param S is the server's operation.
     */
    public static Operation[] transformDelete(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        int idxC = C.leftIdx;
        int idxS = S.leftIdx;
        Operation cPrime = new Operation(C); // to be executed by C
        Operation sPrime = new Operation(S); // to be executed by S
        // S deleted at a position after C's deletion
        if (idxS > idxC) {
            sPrime.leftIdx -= 1;
        }
        // S deleted at a position before C's deletion
        if (idxS < idxC) {
            cPrime.leftIdx -= 1;
        }
        // S and C deleted at the same position
        if (idxS == idxC) {
            cPrime.type = Operation.NO_OP;
            sPrime.type = Operation.NO_OP;
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    /**
     * Client made an insertion, server made a deletion.
     */
    public static Operation[] transformInsertDelete(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        int idxC = C.leftIdx;
        int idxS = S.leftIdx;
        Operation cPrime = new Operation(C);
        Operation sPrime = new Operation(S);
        // S deletes at a position after C's insertion
        if (idxS > idxC) {
            sPrime.leftIdx += C.content.length();
        }
        // S deletes at a position before C's insertion
        if (idxS < idxC) {
            cPrime.leftIdx -= 1;
        }
        // S deletes at the same position of C's insertion
        if (idxS == idxC) {
            cPrime.leftIdx -= 1;
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    /**
     * Client made a deletion, server made an insertion.
     */
    public static Operation[] transformDeleteInsert(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        int idxC = C.leftIdx;
        int idxS = S.leftIdx;
        Operation cPrime = new Operation(C);
        Operation sPrime = new Operation(S);
        if (idxS > idxC) {
            // Server inserts at a later position than client deletion
            sPrime.leftIdx -= 1;
        }
        if (idxS < idxC) {
            // Server inserts at an earlier position than client deletion
            cPrime.leftIdx += S.content.length();
        }
        if (idxS == idxC) {
            sPrime.leftIdx -= S.content.length();
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    /**
     * Transforms client operation against server operation.  Server operation
     * takes precedence. This means we always transform our operations under the
     * assumption that the server operation is applied first.
     */
    public static Operation[] transformBatch(Operation client, Operation server) {
        Operation[] ops = new Operation[2];
        if (client.type == INSERT && server.type == INSERT) {
            return transformBatchedInserts(client, server);
        }
        if (client.type == DELETE && server.type == DELETE) {
            return transformBatchedDeletes(client, server);
        }
        return ops;
    }

    /**
     * Transforms two insert operations. Returns two operations, one the client
     * should apply and one the server should apply to reach a consistent state.
     */
    private static Operation[] transformBatchedInserts(Operation C, Operation S) {
        Operation[] ops = new Operation[2]; // [c'][s']
        int idxC = C.leftIdx;
        int idxS = S.leftIdx;
        Operation cPrime = new Operation(C); // to be executed by S
        Operation sPrime = new Operation(S); // to be executed by C

        if (idxS > idxC) {
            sPrime.leftIdx += C.content.length();
        }
        if (idxS < idxC) {
            cPrime.leftIdx += S.content.length();
        }
        if (idxS == idxC) {
            cPrime.leftIdx += S.content.length();
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }


    /**
     * Transforms two delete operations.
     */
    private static Operation[] transformBatchedDeletes(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        Operation cPrime = new Operation(C); // c', server executes
        Operation sPrime = new Operation(S); // s', client executes

        int sLeft = S.leftIdx; // Right index for delete
        int sRight = S.rightIdx; // Left index for delete
        int serverNumDeleted = sRight - sLeft; // Num chars deleted
        int cLeft = C.leftIdx; // Right index for delete
        int cRight = C.rightIdx; // Left index for delete
        int clientNumDeleted = cRight - cLeft; // Num chars deleted

        // Both server and client deleted the same frame
        if (sRight == cRight && sLeft == cLeft) {
            sPrime = new Operation(Operation.NO_OP);
            cPrime = new Operation(Operation.NO_OP);
        }
        // Deletion windows do not intersect
        else if (sLeft >= cRight) {
            // xxx[CCC]yyy[SSS]
//            System.err.println("CASE1");
            // Shift deletion indices by number of chars client deleted
            sPrime.leftIdx -= clientNumDeleted;
            sPrime.rightIdx -= clientNumDeleted;
        }
        else if (cLeft >= sRight) {
            // xxx[SSS]yyy[CCC]
//            System.err.println("CASE2");
            // Shift deletion indices by number of chars server deleted
            cPrime.leftIdx -= serverNumDeleted;
            cPrime.rightIdx -= serverNumDeleted;
        }
        // Deletion window intersects
        else if (sLeft <= cLeft) {
            if (sRight > cRight) {
                // Server's deletes covers client's delete
//                System.err.println("CASE5");
                int numRight = sRight - cRight;
                int numLeft = cLeft - sLeft;
                sPrime.rightIdx = sPrime.rightIdx - clientNumDeleted + numRight;
                sPrime.leftIdx = sPrime.leftIdx - clientNumDeleted + numLeft;
                cPrime = new Operation(Operation.NO_OP);
            }
            else {
                // Client on right, Server on left, partial overlap
//                System.err.println("CASE3");
                int overlap = sRight - cLeft;
                sPrime.rightIdx -= overlap;
                cPrime.rightIdx -= serverNumDeleted;
                cPrime.leftIdx -= overlap;
            }
        }
        else if (cLeft <= sLeft) {
            if (cRight > sRight) {
                // Client's deletes covers server's delete
//                System.err.println("CASE6");
                int numRight = cRight - sRight;
                int numLeft = sLeft - cLeft;
                cPrime.rightIdx = cPrime.rightIdx - serverNumDeleted + numRight;
                cPrime.leftIdx = cPrime.leftIdx - serverNumDeleted + numLeft;
                sPrime = new Operation(Operation.NO_OP);
            }
            else {
                // Server on right, Client on left, partial overlap
//                System.err.println("CASE4");
                int overlap = cRight - sLeft;
                cPrime.rightIdx -= overlap;
                sPrime.rightIdx -= clientNumDeleted;
                sPrime.leftIdx -= overlap;
            }
        }
        ops[0] = sPrime;
        ops[1] = cPrime;
        return ops;
    }

    /**
     * Client deleted, Server inserted
     */
    private static Operation[] transformedBatchedInsertDelete(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        Operation cPrime = new Operation(C); // c', server executes
        Operation sPrime = new Operation(S); // s', client executes
        int cLeft = C.leftIdx;
        int sLeft = S.leftIdx;
        int sRight = S.rightIdx;
        int numServerDeleted = sRight - sLeft;
        // S deletes at a position after C's insertion
        if (sLeft >= cLeft) {
            sPrime.leftIdx += C.content.length();
            sPrime.rightIdx += C.content.length();
        }
        // S deletes at a position before C's insertion
        if (sRight <= cLeft) {
            cPrime.leftIdx -= numServerDeleted;
        }
        // S deletes the region C inserted at
        if (sLeft < cLeft && sRight > cLeft) {
            cPrime.leftIdx = S.leftIdx;
            sPrime = new Operation(Operation.REPLACE);
            sPrime.content = C.content;
            sPrime.leftIdx = C.leftIdx;
            sPrime.rightIdx = C.content.length() + S.rightIdx;
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    private static Operation[] transformedBatchedDeleteInsert(Operation C, Operation S) {
        Operation[] ops = new Operation[2];
        Operation cPrime = new Operation(C); // c', server executes
        Operation sPrime = new Operation(S); // s', client executes
        int sLeft = S.leftIdx;
        int cLeft = C.leftIdx;
        int cRight = C.rightIdx;
        int numClientDeleted = cRight - cLeft;
        // C deletes at a position after S's insertion
        if (cLeft >= sLeft) {
            cPrime.leftIdx += S.content.length();
            cPrime.rightIdx += S.content.length();
        }
        // S deletes at a position before C's insertion
        if (cRight <= sLeft) {
            sPrime.leftIdx -= numClientDeleted;
        }
        // S deletes the region C inserted at
        if (cLeft < sLeft && cRight > sLeft) {
            sPrime.leftIdx = C.leftIdx;
            cPrime = new Operation(Operation.REPLACE);
            cPrime.content = S.content;
            cPrime.leftIdx = S.leftIdx;
            cPrime.rightIdx = S.content.length() + C.rightIdx;
        }
        ops[0] = cPrime;
        ops[1] = sPrime;
        return ops;
    }

    @Override
    /**
     * String representation of an Operation. We call .trim() on the content
     * to eliminate carriage returns / newlines. Not intended to be used to
     * parse instructions to use for applying an Operation to a text file.
     */
    public String toString() {
        String character = content;
        if (character.equals("\r")) {
            character = "RETURN";
        }
        if (character.equals("\n")) {
            character = "NEWLINE";
        }
        if (character.equals("\r\n")) {
            character = "CARRIAGE RETURN";
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[(");
        sb.append(clientId);
        sb.append(" ");
        sb.append(opsGenerated);
        sb.append(",");
        sb.append(opsReceived);
        sb.append(") ");
        if (type == INSERT) {
            sb.append("INS ");
        }
        if (type == DELETE) {
            sb.append("DEL ");
        }
        if (type == ACK) {
            sb.append("ACK]");
            return sb.toString();
        }
        if (type == CONNECT) {
            sb.append("CONNECT]");
            return sb.toString();
        }
        sb.append(leftIdx);
        sb.append(":");
        sb.append(rightIdx);
        sb.append(" ");
        sb.append(character);
        sb.append("]");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Operation) {
            Operation other = (Operation) obj;
            return opsGenerated == other.opsGenerated &&
                    opsReceived == other.opsReceived &&
                    type == other.type && leftIdx == other.leftIdx &&
                    rightIdx == other.rightIdx && content.equals(other.content) &&
                    clientId == other.clientId;
        }
        return false;
    }
}
